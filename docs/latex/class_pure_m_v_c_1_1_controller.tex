\hypertarget{class_pure_m_v_c_1_1_controller}{
\section{PureMVC::Controller Class Reference}
\label{class_pure_m_v_c_1_1_controller}\index{PureMVC::Controller@{PureMVC::Controller}}
}


A \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_controller}{IController}} implementation.  


{\ttfamily \#include $<$pmvcpp.h$>$}Inheritance diagram for PureMVC::Controller:Collaboration diagram for PureMVC::Controller:\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_pure_m_v_c_1_1_controller_a95c56822d667e94b031451729ce069a9}{Controller} ()
\begin{DoxyCompactList}\small\item\em Constructor. \item\end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{class_pure_m_v_c_1_1_controller_ab6508e0255a6b20c70a9abef7ea799cd}{executeCommand} (\hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification} $\ast$note)
\begin{DoxyCompactList}\small\item\em If an {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} has previously been registered to handle a the given {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}}, then it is executed. \item\end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{class_pure_m_v_c_1_1_controller_a3e841777e38b7a571aa43aeb9ba40fed}{registerCommand} (int notificationName)
\begin{DoxyCompactList}\small\item\em Register a particular {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} class as the handler for a particular {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}}. \item\end{DoxyCompactList}\item 
bool \hyperlink{class_pure_m_v_c_1_1_controller_ab434278b9236beb9d5ffb55482233ef9}{hasCommand} (int notificationName)
\begin{DoxyCompactList}\small\item\em Check if a Command is registered for a given \hyperlink{class_pure_m_v_c_1_1_notification}{Notification}. \item\end{DoxyCompactList}\item 
void \hyperlink{class_pure_m_v_c_1_1_controller_a3d6617b86454aad7db4d47d32e692c64}{removeCommand} (int notificationName)
\begin{DoxyCompactList}\small\item\em Remove a previously registered {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} to {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}} mapping. \item\end{DoxyCompactList}\item 
virtual void \hyperlink{class_pure_m_v_c_1_1_multiton_key_heir_abc70ef7c066bc8d7bf0196ec727599bb}{setMultitonKey} (std::string key)
\begin{DoxyCompactList}\small\item\em Set multiton key. \item\end{DoxyCompactList}\item 
virtual std::string \hyperlink{class_pure_m_v_c_1_1_multiton_key_heir_aa5622459d33380deb08dc3cab8b991c7}{getMultitonKey} ()
\begin{DoxyCompactList}\small\item\em Get multiton key. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{class_pure_m_v_c_1_1_i_controller}{IController} $\ast$ \hyperlink{class_pure_m_v_c_1_1_controller_aa36b55f117c5aa573c6e1894f0d98195}{getInstance} (std::string key)
\begin{DoxyCompactList}\small\item\em {\ttfamily \hyperlink{class_pure_m_v_c_1_1_controller}{Controller}} \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} Factory method. \item\end{DoxyCompactList}\item 
static void \hyperlink{class_pure_m_v_c_1_1_controller_a802f04dc749c8ddc8f0af2ed8db2e257}{removeController} (std::string key)
\begin{DoxyCompactList}\small\item\em Remove an \hyperlink{class_pure_m_v_c_1_1_i_controller}{IController} instance. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_pure_m_v_c_1_1_controller_a071c576f4a0cee162f8f7355767dc247}{initializeController} ()
\begin{DoxyCompactList}\small\item\em Initialize the \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} {\ttfamily \hyperlink{class_pure_m_v_c_1_1_controller}{Controller}} instance. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_pure_m_v_c_1_1_controller_a53a316e216212890d3b15e379b1edf82}{
\hyperlink{class_pure_m_v_c_1_1_i_view}{IView} $\ast$ {\bfseries view}}
\label{class_pure_m_v_c_1_1_controller_a53a316e216212890d3b15e379b1edf82}

\item 
\hypertarget{class_pure_m_v_c_1_1_controller_a7f5fdd0c009101c605029ea6adb4a578}{
std::map$<$ int, \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand} $\ast$ $>$ {\bfseries commandMap}}
\label{class_pure_m_v_c_1_1_controller_a7f5fdd0c009101c605029ea6adb4a578}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
A \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_controller}{IController}} implementation. In \hyperlink{namespace_pure_m_v_c}{PureMVC}, the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_controller}{Controller}} class follows the 'Command and Controller' strategy, and assumes these responsibilities: 
\begin{DoxyItemize}
\item Remembering which {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}}s are intended to handle which {\ttfamily INotifications}. 
\item Registering itself as an {\ttfamily IObserver} with the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_view}{View}} for each {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}} that it has an {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} mapping for. 
\item Creating a new instance of the proper {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} to handle a given {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}} when notified by the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_view}{View}}. 
\item Calling the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}}'s {\ttfamily execute} method, passing in the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}}. 
\end{DoxyItemize}

Your application must register {\ttfamily ICommands} with the \hyperlink{class_pure_m_v_c_1_1_controller}{Controller}. 

The simplest way is to subclass \hyperlink{class_pure_m_v_c_1_1_facade}{Facade}, and use its {\ttfamily initializeController} method to add your registrations.

\begin{DoxySeeAlso}{See also}
\hyperlink{class_pure_m_v_c_1_1_view}{View} 

\hyperlink{class_pure_m_v_c_1_1_observer}{Observer} 

\hyperlink{class_pure_m_v_c_1_1_notification}{Notification} 

\hyperlink{class_pure_m_v_c_1_1_simple_command}{SimpleCommand} 

\hyperlink{class_pure_m_v_c_1_1_macro_command}{MacroCommand} 
\end{DoxySeeAlso}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_pure_m_v_c_1_1_controller_a95c56822d667e94b031451729ce069a9}{
\index{PureMVC::Controller@{PureMVC::Controller}!Controller@{Controller}}
\index{Controller@{Controller}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{Controller}]{\setlength{\rightskip}{0pt plus 5cm}Controller::Controller ()}}
\label{class_pure_m_v_c_1_1_controller_a95c56822d667e94b031451729ce069a9}


Constructor. This {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_controller}{IController}} implementation is a \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton}, so you should not call the constructor directly, but instead call the static Factory method, passing the unique key for this instance {\ttfamily Controller.getInstance( multitonKey )}


\begin{DoxyExceptions}{Exceptions}
\item[{\em Error}]Error if instance for this \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} key has already been constructed \end{DoxyExceptions}


\subsection{Member Function Documentation}
\hypertarget{class_pure_m_v_c_1_1_controller_ab6508e0255a6b20c70a9abef7ea799cd}{
\index{PureMVC::Controller@{PureMVC::Controller}!executeCommand@{executeCommand}}
\index{executeCommand@{executeCommand}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{executeCommand}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void PureMVC::Controller::executeCommand ({\bf INotification} $\ast$ {\em note})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{class_pure_m_v_c_1_1_controller_ab6508e0255a6b20c70a9abef7ea799cd}


If an {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} has previously been registered to handle a the given {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}}, then it is executed. 
\begin{DoxyParams}{Parameters}
\item[{\em note}]an {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}} \end{DoxyParams}
\hypertarget{class_pure_m_v_c_1_1_controller_aa36b55f117c5aa573c6e1894f0d98195}{
\index{PureMVC::Controller@{PureMVC::Controller}!getInstance@{getInstance}}
\index{getInstance@{getInstance}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{getInstance}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IController} $\ast$ Controller::getInstance (std::string {\em key})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{class_pure_m_v_c_1_1_controller_aa36b55f117c5aa573c6e1894f0d98195}


{\ttfamily \hyperlink{class_pure_m_v_c_1_1_controller}{Controller}} \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} Factory method. \begin{DoxyReturn}{Returns}
the \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} instance of {\ttfamily \hyperlink{class_pure_m_v_c_1_1_controller}{Controller}} 
\end{DoxyReturn}
\hypertarget{class_pure_m_v_c_1_1_multiton_key_heir_aa5622459d33380deb08dc3cab8b991c7}{
\index{PureMVC::Controller@{PureMVC::Controller}!getMultitonKey@{getMultitonKey}}
\index{getMultitonKey@{getMultitonKey}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{getMultitonKey}]{\setlength{\rightskip}{0pt plus 5cm}std::string MultitonKeyHeir::getMultitonKey ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, inherited\mbox{]}}}}
\label{class_pure_m_v_c_1_1_multiton_key_heir_aa5622459d33380deb08dc3cab8b991c7}


Get multiton key. Returns the multiton key. \begin{DoxyReturn}{Returns}
The string key name 
\end{DoxyReturn}


Implements \hyperlink{class_pure_m_v_c_1_1_i_multiton_key_heir_aecccfb9898368c6377550ceae5730934}{PureMVC::IMultitonKeyHeir}.\hypertarget{class_pure_m_v_c_1_1_controller_ab434278b9236beb9d5ffb55482233ef9}{
\index{PureMVC::Controller@{PureMVC::Controller}!hasCommand@{hasCommand}}
\index{hasCommand@{hasCommand}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{hasCommand}]{\setlength{\rightskip}{0pt plus 5cm}bool Controller::hasCommand (int {\em notificationName})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{class_pure_m_v_c_1_1_controller_ab434278b9236beb9d5ffb55482233ef9}


Check if a Command is registered for a given \hyperlink{class_pure_m_v_c_1_1_notification}{Notification}. 
\begin{DoxyParams}{Parameters}
\item[{\em notificationName}]\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether a Command is currently registered for the given {\ttfamily notificationName}. 
\end{DoxyReturn}


Implements \hyperlink{class_pure_m_v_c_1_1_i_controller_a0cb56adf2c1300913af0458ba730cbf4}{PureMVC::IController}.\hypertarget{class_pure_m_v_c_1_1_controller_a071c576f4a0cee162f8f7355767dc247}{
\index{PureMVC::Controller@{PureMVC::Controller}!initializeController@{initializeController}}
\index{initializeController@{initializeController}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{initializeController}]{\setlength{\rightskip}{0pt plus 5cm}void Controller::initializeController ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_pure_m_v_c_1_1_controller_a071c576f4a0cee162f8f7355767dc247}


Initialize the \hyperlink{class_pure_m_v_c_1_1_multiton}{Multiton} {\ttfamily \hyperlink{class_pure_m_v_c_1_1_controller}{Controller}} instance. Called automatically by the getInstance

\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\hypertarget{class_pure_m_v_c_1_1_controller_a3e841777e38b7a571aa43aeb9ba40fed}{
\index{PureMVC::Controller@{PureMVC::Controller}!registerCommand@{registerCommand}}
\index{registerCommand@{registerCommand}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{registerCommand}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void PureMVC::Controller::registerCommand (int {\em notificationName})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{class_pure_m_v_c_1_1_controller_a3e841777e38b7a571aa43aeb9ba40fed}


Register a particular {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} class as the handler for a particular {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}}. If an {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} has already been registered to handle {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}}s with this name, it is no longer used, the new {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} is used instead.

The \hyperlink{class_pure_m_v_c_1_1_observer}{Observer} for the new \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand} is only created if this the first time an \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand} has been regisered for this \hyperlink{class_pure_m_v_c_1_1_notification}{Notification} name.

commandClassRef the {\ttfamily Class} of the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} 
\begin{DoxyParams}{Parameters}
\item[{\em notificationName}]the name of the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}} \end{DoxyParams}
\hypertarget{class_pure_m_v_c_1_1_controller_a3d6617b86454aad7db4d47d32e692c64}{
\index{PureMVC::Controller@{PureMVC::Controller}!removeCommand@{removeCommand}}
\index{removeCommand@{removeCommand}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{removeCommand}]{\setlength{\rightskip}{0pt plus 5cm}void Controller::removeCommand (int {\em notificationName})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{class_pure_m_v_c_1_1_controller_a3d6617b86454aad7db4d47d32e692c64}


Remove a previously registered {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} to {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}} mapping. 
\begin{DoxyParams}{Parameters}
\item[{\em notificationName}]the name of the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_notification}{INotification}} to remove the {\ttfamily \hyperlink{class_pure_m_v_c_1_1_i_command}{ICommand}} mapping for \end{DoxyParams}


Implements \hyperlink{class_pure_m_v_c_1_1_i_controller_a5d646a36a3d7fc08a0cefb17662ce8ef}{PureMVC::IController}.\hypertarget{class_pure_m_v_c_1_1_controller_a802f04dc749c8ddc8f0af2ed8db2e257}{
\index{PureMVC::Controller@{PureMVC::Controller}!removeController@{removeController}}
\index{removeController@{removeController}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{removeController}]{\setlength{\rightskip}{0pt plus 5cm}void Controller::removeController (std::string {\em key})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{class_pure_m_v_c_1_1_controller_a802f04dc749c8ddc8f0af2ed8db2e257}


Remove an \hyperlink{class_pure_m_v_c_1_1_i_controller}{IController} instance. 
\begin{DoxyParams}{Parameters}
\item[{\em multitonKey}]of \hyperlink{class_pure_m_v_c_1_1_i_controller}{IController} instance to remove \end{DoxyParams}
\hypertarget{class_pure_m_v_c_1_1_multiton_key_heir_abc70ef7c066bc8d7bf0196ec727599bb}{
\index{PureMVC::Controller@{PureMVC::Controller}!setMultitonKey@{setMultitonKey}}
\index{setMultitonKey@{setMultitonKey}!PureMVC::Controller@{PureMVC::Controller}}
\subsubsection[{setMultitonKey}]{\setlength{\rightskip}{0pt plus 5cm}void MultitonKeyHeir::setMultitonKey (std::string {\em key})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, inherited\mbox{]}}}}
\label{class_pure_m_v_c_1_1_multiton_key_heir_abc70ef7c066bc8d7bf0196ec727599bb}


Set multiton key. Sets the multiton key. 
\begin{DoxyParams}{Parameters}
\item[{\em key}]The name of the key \end{DoxyParams}


Implements \hyperlink{class_pure_m_v_c_1_1_i_multiton_key_heir_a03acb75ab79defba2c28b8de1bbe1ca6}{PureMVC::IMultitonKeyHeir}.

The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/Users/schell/Code/PureMVC-\/Plus-\/Plus/src/pmvcpp.h\item 
/Users/schell/Code/PureMVC-\/Plus-\/Plus/src/pmvcpp.cpp\end{DoxyCompactItemize}
